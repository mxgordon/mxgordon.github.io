use std::rc::Rc;
use std::time::Duration;
use std::{cell::RefCell, fmt::Debug};
use std::any::Any;
use html::{a, div, h2, h3, iframe, img, li, p, span, ul};
use leptos::*;
use leptos::attr::Attribute;
use leptos::attr::custom::{custom_attribute, CustomAttr};
use leptos::html::ElementType;
use leptos::logging::log;
use leptos::prelude::{create_node_ref, document, set_interval_with_handle, window, AnyView, CustomAttribute, IntoAny, NodeRef};
use leptos_dom::helpers::IntervalHandle;
use wasm_bindgen::prelude::Closure;
use wasm_bindgen::JsCast;
use wasm_bindgen_test::console_error;
use web_sys::{Element, HtmlElement, Node};

#[derive()]
enum TypeElement {
    Text { t: String },
    Element { e: AnyView },
    EndElement(),
    StartText(),
    EndText(),
    Comment{ c: Node},
}

impl Debug for TypeElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TypeElement::Text { t } => f.write_str(&format!("Text: {}", t)),
            TypeElement::Element { e } => f.write_str(&format!("Element: {:?}", e)),
            TypeElement::EndElement() => f.write_str("EndElement"),
            TypeElement::StartText() => f.write_str("StartText"),
            TypeElement::EndText() => f.write_str("EndText"),
            TypeElement::Comment{c} => f.write_str(&format!("Comment: {}", c.text_content().unwrap_or_default())),
        }
    }
}

fn break_down_html<'a>(
    html: &HtmlElement,
    seq: &'a mut Vec<TypeElement>,
    chunk_sz: usize
) -> &'a mut Vec<TypeElement> {
    break_down_node(&html.get_root_node(), seq, chunk_sz)
}

fn break_down_node<'a>(root: &Node, seq: &'a mut Vec<TypeElement>, chunk_sz: usize) -> &'a mut Vec<TypeElement> {
    let root_name = root.node_name();

    if root.node_type() == 3 {
        seq.push(TypeElement::StartText());

        let text = root.text_content().unwrap();
        let mut chars = text.chars().peekable();

        while chars.peek().is_some() {
            let s: String = chars.clone().take(chunk_sz).collect();
            for _ in 0..chunk_sz {
                chars.next();
            }

            seq.push(TypeElement::Text { t: s });
        }

        seq.push(TypeElement::EndText());

        return seq;
    } else if root.node_type() == 8 { // Copy comments as well (generally generated by Leptos)
        seq.push(TypeElement::Comment{c: root.clone()});
        return seq;
    }

    let root_element: Element = root.clone().dyn_into().unwrap();

    let attrs = root_element.get_attribute_names();

    // let attrs: Vec<CustomAttr<String, String>> = attrs.iter().map(|attr| {
    //     let name = attr.as_string().unwrap().to_owned();
    //     let value = root_element.get_attribute(&name).unwrap();
    //
    //     custom_attribute(name, value)
    // }).collect();

    // let attrs: Vec<(&'static str, Attribute)> = attrs
    //     .iter()
    //     .map(|attr| {
    //         let name = attr.as_string().unwrap().to_owned();
    //         let name_str: &'static str = Box::leak(name.into_boxed_str());
    //
    //         let value = root_element.get_attribute(&name_str).unwrap();
    //
    //         // String::AttributeValue(name_str, value);
    //         (name_str, Attribute::String(value.into()))
    //     })
    //     .collect();

    let mut next_element: AnyView = match root_name.as_str() {
        "P" => p().into_any(),
        "SPAN" => span().into_any(),
        "A" => a().into_any(),
        "H2" => h2().into_any(),
        "H3" => h3().into_any(),
        "UL" => ul().into_any(),
        "LI" => li().into_any(),
        "IMG" => img().into_any(),
        "DIV" => div().into_any(),
        "IFRAME" => iframe().into_any(),
        other => {
            // log!("Unknown element: {}", other);
            // None
            console_error!("Unknown element: {}", other);
            panic!();
        }
    };

    for attr_name in attrs {
        let name = attr_name.as_string().unwrap().to_owned();
        let value = root_element.get_attribute(&name).unwrap();

        next_element = next_element.attr(name, value).into_any();
    }

    // let _ = next_element
    //     .clone()
    //     .expect(format!("Element: {} should be initialized", root_name.as_str()).as_str()).at
        // .attrs(attrs);

    // next_element.unwrap().attr

    seq.push(TypeElement::Element {
        e: next_element.into(),
    });

    for i in 0..root.child_nodes().length() {
        let child = root.child_nodes().get(i).unwrap();
        break_down_node(&child, seq, chunk_sz);
    }

    seq.push(TypeElement::EndElement());

    seq
}


#[component]
pub fn TypeWriter(
    #[prop(into)] html_to_type: HtmlElement,
    #[prop(default=div().into(), into)] base_element: HtmlElement,
    #[prop(default=20)] delay: u64,
    #[prop(default=Box::new(|| ()))] callback: Box<dyn Fn() + 'static>,
    #[prop(default=6)] chunk_sz: usize,
) -> impl IntoView {
    let container_div_ref = NodeRef::new();

    let mut charSeq: Vec<TypeElement> = Vec::new();

    break_down_html(&html_to_type, &mut charSeq, chunk_sz);

    // base_element.add_event_listener_with_callback_and_add_event_listener_options_and_wants_untrusted()
    // base_element.on

    // let onscroll_closure = Closure::wrap(Box::new(|e: web_sys::Event| { log!("scroll: {:?}", e); }) as Box<dyn FnMut(_)>);
    // document().set_onscroll(Some(onscroll_closure.as_ref().unchecked_ref()));
    // onscroll_closure.forget();

    container_div_ref.on_load(move |e| {
        let _ = e.on_mount(move |e| {
            let idxRef = RefCell::new(0);
            let intervalHandleRef: Rc<RefCell<Option<IntervalHandle>>> =
                Rc::new(RefCell::new(None));

            let current_element: RefCell<HtmlElement> = RefCell::new(e.into());
            let current_text: RefCell<Option<Node>> = RefCell::new(None);


            let cb = {
                let intervalHandleRef = intervalHandleRef.clone();
                move || {
                    let mut current_element = current_element.borrow_mut();
                    let mut idx = idxRef.borrow_mut();
                    let mut current_text = current_text.borrow_mut();

                    let mut iter_again = true;

                    while iter_again {
                        if *idx >= charSeq.len() {

                            intervalHandleRef.borrow_mut().unwrap().clear();
                            callback();
                            // document().set_onscroll(None); // Remove onscroll callback
                            return;
                        }

                        let next = &charSeq[*idx];

                        match next {
                            TypeElement::EndElement() => {
                                let classes = current_element.class_name();
                                current_element.set_attribute("class", &classes.replace("typing", "")).unwrap();

                                let parent_node = current_element.parent_element().unwrap();
                                *current_element = parent_node;
                                    // ToHtmlElement::to_leptos_element(&parent_node);
                            }
                            TypeElement::Text { t } => {
                                let mut text = current_text
                                    .as_ref()
                                    .unwrap()
                                    .text_content()
                                    .unwrap_or_default();

                                text.push_str(&t);

                                current_text.as_ref().unwrap().set_text_content(Some(&text));
                                
                                let window = window();
                                let document = document();
                                let body = document.body().unwrap();
                                let current_scroll = window.scroll_y().unwrap();
                                let target_scroll = body.scroll_height() as f64 - window.inner_height().unwrap().as_f64().unwrap();
                            
                                if (current_scroll + 1.) < target_scroll {  // +1 to avoid floating point errors
                                    window.scroll_to_with_x_and_y(0.0, target_scroll);
                                }


                                iter_again = false;
                            }
                            TypeElement::Element { e } => {
                                let classes = current_element.class_name();
                                current_element.class_list().remove_1("typing").unwrap();

                                current_element.append_child(&e).unwrap();
                                *current_element = e;

                                current_element.class_list().add_1("typing").unwrap();
                            }
                            TypeElement::StartText() => {
                                let _ = current_element.append_with_str_1("");

                                *current_text = Some(current_element.last_child().unwrap()); // unwrapping then Some, so it'll panic if something weird happens
                            }
                            TypeElement::EndText() => {
                                *current_text = None;
                            }
                            TypeElement::Comment{c} => {
                                let _ = current_element.append_child(&c);
                            }
                        }

                        *idx += 1;
                    }
                }
            };
            *intervalHandleRef.borrow_mut() =
                set_interval_with_handle(cb, Duration::from_millis(delay)).ok();
        });
    });

    // base_element.node_re

    base_element.set_onload(move |e| {print!("loaded");})

    // base_element.n
        // .node_ref(container_div_ref)
}
